// *******************************************************************************************************
// ****************************************** gestion moteur *********************************************
// *******************************************************************************************************
#include <SparkFunMiniMoto.h> // Include the MiniMoto library

// Create  MiniMoto instances, pour controle des moteur en I2C (DRV8830)
MiniMoto motor[4] = {gain_0_motor, vol_0_motor, gain_1_motor, vol_1_motor};

/*In this section we have defined the gain values for the
   proportional,integral, and derivative controller i have set
   the gain values with the help of trial and error methods.
*/
#define ECART_V_STOP 5 // hystérésie de positionnement potentiomètre

#define PID
// #define AUTOPID

#ifdef PID
#include "QuickPID.h"
// Define the aggressive and conservative and POn Tuning Parameters
float aggKp = 2, aggKi = 0.5, aggKd = 0.5;
float consKp = 1, consKi = 0.05, consKd = 0.25;

#define ECART_V_STOP 5 // hystérésie de positionnement potentiomètre
#define pid_windup 10
#define pid_limit_min 6
#define pid_limit_max 63
#define pid_bias 255.0
#define pid_time_step 1000
#define gap_setpoint 25
float pid_input, pid_output, pid_setpoint;
QuickPID myPID(&pid_input, &pid_output, &pid_setpoint);

#endif

#ifdef AUTOPID
#include <AutoPID.h>
// pid settings and gains
#define PID_TimeStep 250 // set PID update interval to 4000ms
#define OUTPUT_MIN 100
#define OUTPUT_MAX 1000
#define KP .12
#define KI .0003
#define KD 0
double motor_read, motor_set, out_speed_value;
AutoPID myPID(&motor_read, &motor_set, &out_speed_value, OUTPUT_MIN, OUTPUT_MAX, KP, KI, KD);
#endif

void moteur_set(int i);
void moteur_stop(int i);
void pid_set(int i);
void pid_setup();

void pid_setup()
{
#ifdef PID
        myPID.SetMode(myPID.Control::automatic);
        // myPID.SetMode(myPID.Control::manual);
        // myPID.SetSampleTimeUs(pid_time);
        myPID.SetOutputLimits(pid_limit_min, pid_limit_max); // Limit the PID output this is important to get rid of integral windup!
        // myPID.setBias(pid_bias / 2.0);                  // Set the bias to 127.5, this is the center of the output range
        myPID.SetAntiWindupMode(myPID.iAwMode::iAwCondition); // Set the anti-windup mode to "do nothing"
#endif
#ifdef AUTOPID
        myPID.setBangBang(ECART_V_STOP);
        myPID.setTimeStep(PID_TimeStep);
#endif
}

void pid_set(int i)
{
#ifdef PID
        pid_input = float(position_lue[i]);
        pid_setpoint = float(position_set[i]);
        float gap = abs(pid_setpoint - pid_input); // distance away from setpoint
        if (gap < gap_setpoint)
        { // we're close to setpoint, use conservative tuning parameters
                myPID.SetTunings(consKp, consKi, consKd);
        }
        else
        {
                // we're far from setpoint, use aggressive tuning parameters
                myPID.SetTunings(aggKp, aggKi, aggKd);
        }
#ifdef DEBUG          // si DEBUG activé
        breakpoint(); // point d'arrêt pour le debug
#endif
        myPID.Compute(); // Let the PID compute the value, returns the calculated optimal output
#endif
}

void moteur_stop(int i)
{
#ifdef AUTOPID
        myPID.stop();
#endif
#ifdef PID
        //   myPID.stop();
        myPID.SetMode(myPID.Control::manual);
#endif
        motor[i].stop();                   // stop moteur
        delay(50);                         // attente 50ms
        lecture_pot(i);                    // lecture analogique du potentiomètre
        motor_change[i] = false;           // remise à zéro du flag de changement de position du potentiomètre
        position_set[i] = position_lue[i]; // remise à zéro de la consigne de position du potentiomètre
        last_change_time = millis();       // sauvegarde du temps du dernier changement de position
        // button_position_save();            // sauvegarde de la position des potentiomètres pour sortie constante
}

void moteur_set(int i) // fonction de gestion des moteurs
{
#ifdef PID
        myPID.SetMode(myPID.Control::automatic);
        pid_set(i);
        int motor_speed_value = pid_output; // Let the PID compute the value, returns the calculated optimal output
#endif
#ifdef AUTOPID
        motor_read = position_lue[i]; // The "goal" the PID controller tries to "reach",
        motor_set = position_set[i];  // The "goal" the PID controller tries to "reach",
        myPID.run();                  // Let the PID compute the value, returns the calculated optimal output
        int motor_speed_value = (int)out_speed_value;
        int map_speed_value = map(motor_speed_value, 100, 1000, -63, 63);
        int const_speed_value = constrain(motor_speed_value, -63, 63);
#endif
        if (position_lue[i] == position_set[i] || position_set[i] > 1023 || position_set[i] < 0) // si position lue égale à la consigne ou consigne hors bornes
        {
                moteur_stop(i);
                return;
        }
        else if (position_lue[i] < (position_set[i] + ECART_V_STOP) && position_lue[i] > (position_set[i] - ECART_V_STOP)) // si moteur entre consigne et ECART_V_STOP
        {
                moteur_stop(i);
                return;
        }
        // *******************************************************************************************************
        // si moteur doit aller vers la gauche
        else if (position_lue[i] > (position_set[i] + (ECART_V_STOP / 2))) // si moteur n'est pas entre consigne et ECART_V_STOP
        {
                motor_change[i] = true;
                motor[i].drive(-motor_speed_value);
        }
        else if (position_lue[i] < (position_set[i] - (ECART_V_STOP / 2))) // si moteur n'est pas entre consigne et ECART_V_STOP
        {
                motor_change[i] = true;
                motor[i].drive(motor_speed_value);
        }
        else
        {
                motor[i].brake(); // stop moteur
                moteur_stop(i);
                return;
        }
}